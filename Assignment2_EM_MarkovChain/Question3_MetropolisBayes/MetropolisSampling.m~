% Pstar = function handle from which to simulate from, used to compute
% acceptance probability
% Target distribution = P = Pstar / Z, where Z = normalizing constant so
% that Pstar becomes a probability distribution. 
% L = lengthscale (range) of the Pstar function. 
% proposalWidth = standard deviation (lengthscale) of the proposal distribution. 
% Q = proposal distribution = Normal(mu_t, epsilon). 

% N = number of samples to draw, after burn in

%% OUTPUT: 
% X = the markov chain sequence (samples) from the target distribution. 
% X represents the samples from the posterior, P = P* / Z

function [X] = MetropolisSampling(N, L, proposalWidth, Pstar)
    % parameters
    %burnin = 0; % number of burn-in iterations
    burnin = (L / proposalWidth)^2;
    T = N + burnin; 
    
    % Proposal distribution with current mean and proposal width (sigma)
    sampleProposalQ = @(mu, sigma) normrnd(mu, sigma);
    
    % Preparing the posterior samples using the Markov chain
    X = zeros(N,1); 
    
    % Let first current mean be 0.5 since any beta distribution, and hence
    % the posterior, have x-values between 0 and 1. Let the first xInit
    % be midway between 0 and 1. 
    xInit = 0.5; 
    
    % Sample the proposal distribution
    X(1) = sampleProposalQ(xInit, proposalWidth); 
    
    % Generate N uniform random numbers. 
    u = rand(1, N); 
    
    % Metropolis Routine
    for t = 1:T-1
        % Generate the next proposal value from the symmetric proposal
        % distribution Q
        muProposal = sampleProposalQ(X(t), proposalWidth); 
        
        acceptProb = min(1, Pstar(muProposal) / Pstar(X(t))); % acceptance probability
        
        if u(t) < acceptProb
            X(t + 1) = muProposal; % accepting the new state
        else % if rejected
            X(t + 1) = X(t); % new point is same as the old one
        end
    end
    
    
    % TODO must pick out every Mth sample to get every independent samples.
    % 
    
end

